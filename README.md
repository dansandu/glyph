# Glyph
A simple C++ implementation of a canonical left to right parser with one lookahead terminal.
## Building and deploying the project
We'll use praline to build and deploy the project. You can get it from [here](https://gitlab.com/dansandu/praline) if it's not already up and running. Next, clone the repository to a desired directory and run the following command inside the terminal:
```
praline.py deploy  # build and deploy the artifact to your praline repository
```
## Simple calculator project a.k.a. parsing them strings
Create a new directory `calculator` in your favorite workspace directory and create a `Pralinefile` inside it with the following contents:
```
organization: foobar
artifact: calculator
version: 1.0.0
dependencies:
- organization: dansandu
  artifact: glyph
  version: 1.+0.+0
```
Run the following command inside a terminal to quickly create the project skeleton:
```
praline.py --executable run_main_executable
```
Now comes the code! We'll take it step by step.
In the project directory open the main source file `sources/foobar/calculator/executable.cpp` and change it to:
```
#include "dansandu/glyph/node.hpp"
#include "dansandu/glyph/parser.hpp"
#include "dansandu/glyph/token.hpp"

#include <iostream>
#include <string>
#include <string_view>
#include <vector>

using dansandu::glyph::node::Node;
using dansandu::glyph::parser::Parser;
using dansandu::glyph::token::RegexTokenizer;

// We'll use this function to evaluate the abstract syntax tree generated by the parser.
// You can skip reading this function for now and return to it after you've read the main
// function.
double evaluate(std::string_view formula, const Node& node);

int main(int argumentsCount, char** arguments) {
    if (argumentsCount <= 1) {
        std::cout << "Pass a formula as a program argument in order to parse it!"
                  << std::endl;
        return 0;
    }

    // This is the grammar used to parse arithmetic formulae. Non-terminals start with
    // capital letters while terminals start with lower case letters. Both non-terminals
    // and terminals are restricted to the english alphabet. Notice the indexing of
    // each production rule with comments. We'll use these indicies to evaluate the
    // abstract syntax tree yielded by the parser. Another thing to be aware of is why we
    // chose this grammar. There are many grammars which recognize formulae parsed by this
    // grammar but this one is special because the operator precedence is built-in. We'll
    // let it to the reader to ponder why.
    // clang-format off
    auto grammar = /*0*/ "Start    -> Sums                    \n"
                   /*1*/ "Sums     -> Sums add Products       \n"
                   /*2*/ "Sums     -> Products                \n"
                   /*3*/ "Products -> Products multiply Value \n"
                   /*4*/ "Products -> Value                   \n"
                   /*5*/ "Value    -> number";
    // clang-format on

    // Because terminals are restricted to the english alphabet we need to map identifiers
    // to the actual representation of the terminals in the input string. Here we use the
    // handy regex tokenizer to do so.
    auto terminals = std::vector<RegexTokenizer::Descriptor>{
        {{"add", "\\+"},
         {"multiply", "\\*"},
         {"number", "(?:[1-9]\\d*|0)(?:\\.\\d+)?"},
         {"whitespace", "\\s+"}}};

    // Whitespace doesn't influence the formula evaluation so we discard it from the
    // original string.
    auto discarded = std::vector<std::string>{"whitespace"};

    // The tokenizer implements the call operator which maps substrings from the input
    // string to terminals, returning a vector of tokens.
    auto tokenizer = RegexTokenizer{std::move(terminals), std::move(discarded)};

    // Here we parse an arbitrary string given as a program argument.
    auto formula = arguments[1];
    auto parser = Parser{grammar};
    auto abstractSyntaxTree = parser.parse(formula, tokenizer);

    // We print the results and we are done... after we see what the evaluate function does.
    std::cout << formula << " = " << evaluate(formula, abstractSyntaxTree) << std::endl;
    return 0;
}

// Welcome back! Next we see how to traverse the abstract syntax tree.
double evaluate(std::string_view formula, const Node& node) {
    // Each node holds either a token, which is a terminal in the grammar, or a vector of
    // nodes as children. In the last case the node represents a production rule from the
    // provided grammar where each child is a symbol from the right hand side of the
    // production (the words after the arrow sign '->'). Because each grammar is required
    // to have a start production we can assume that the root node is not a token. Adding
    // the fact that we call this function only on production nodes, as we'll see bellow,
    // we can assume that the node is never a token.
    if (node.isToken())
        throw std::runtime_error{
            "oopsie -- ill-formed syntax tree, node should always be a production rule!"};

    // Notice that we use the production rule index to identify what kind of computation
    // we need to do with its children.
    auto ruleIndex = node.getRuleIndex();
    if (ruleIndex == 0 || ruleIndex == 2 || ruleIndex == 4) {
        // If the current node is the Start production, the Sums to Products production,
        // or the Products to Value production we don't do any computation and just return
        // the evaluation of the its child.
        return evaluate(formula, node.getChild(0));
    } else if (ruleIndex == 1) {
        // We know from the grammar that the right hand side of this production is the
        // summation of the first and third child nodes of the current node.
        return evaluate(formula, node.getChild(0)) +
               evaluate(formula, node.getChild(2));
    } else if (ruleIndex == 3) {
        // Here we do the same for multiplication.
        return evaluate(formula, node.getChild(0)) *
               evaluate(formula, node.getChild(2));
    } else if (ruleIndex == 5) {
        // We now expect a production ending in a token which is a number.
        const auto& token = node.getChild(0).getToken();

        // Each token contains the identifier of the terminal and it's span in the parsed
        // string. We use this span to extract the number from the formula.
        return std::stod(std::string{formula.cbegin() + token.begin(),
                                     formula.cbegin() + token.end()});
    } else {
        // Be sure to exhaust all indicies for all the production rules you define in the
        // grammar.
        throw std::runtime_error{"oopsie -- unrecognized production rule index!"};
    }
}
```
That's the code, now let's run it:
```
praline.py run_main_executable --arguments '3 + 5 * 10 + 40' 
```
This should print something along the lines:
```
2019-06-11 20:26:55,749 INFO praline.common.file_system 3 + 5 * 10 + 40 = 93
```
And there you have it, a simple arithmetic formula parser. Feel free to extend it or even make your own C++ 2.0 compiler. Hopefully with no implicit conversions between booleans and integer types :wink:
